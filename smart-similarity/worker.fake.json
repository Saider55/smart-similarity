// worker.fake.js
// Works everywhere. No external files. No WASM. No transformers.
// Produces deterministic embeddings for testing Bubble plugin workflow.

const DEFAULT_DIM = 32;

function hashToVector(text, dim = DEFAULT_DIM) {
  let h = 2166136261 >>> 0;
  for (let i = 0; i < text.length; i++) {
    h ^= text.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  const out = new Array(dim);
  for (let i = 0; i < dim; i++) {
    h ^= h >>> 13;
    h ^= h << 7;
    h ^= h >>> 17;
    out[i] = (h >>> 0) / 4294967295;
  }
  return out;
}

onmessage = async (e) => {
  const msg = e.data;

  if (msg.type === "ping") {
    postMessage({ type: "pong", id: msg.id });
    return;
  }

  if (msg.type === "load_model") {
    await new Promise(r => setTimeout(r, 150));
    postMessage({
      type: "model_ready",
      model_id: msg.model_id || "fake-model",
      mode: "fake"
    });
    return;
  }

  if (msg.type === "embed") {
    const embedding = hashToVector(String(msg.text));
    postMessage({ type: "embed_result", id: msg.id, embedding });
    return;
  }

  if (msg.type === "batch") {
    const results = msg.texts.map(t => ({
      ok: true,
      embedding: hashToVector(String(t))
    }));
    postMessage({ type: "batch_result", id: msg.id, results });
    return;
  }

  postMessage({ type: "error", error: "Unknown message type" });
};
